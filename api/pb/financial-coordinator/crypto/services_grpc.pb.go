// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: financial-coordinator/crypto/services.proto

package crypto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CryptoDepositClient is the client API for CryptoDeposit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoDepositClient interface {
	// (USER) DepositClaimInit initializes deposit claim
	DepositClaimInit(ctx context.Context, in *DepositClaimInitRequest, opts ...grpc.CallOption) (*DepositClaimInitResponse, error)
	// (USER) DepositClaimPod accepts proof of deposit from user
	DepositClaimPod(ctx context.Context, in *DepositClaimPodRequest, opts ...grpc.CallOption) (*DepositClaimPodResponse, error)
	// (USER) DepositHistory
	DepositHistory(ctx context.Context, in *DepositHistoryRequest, opts ...grpc.CallOption) (*DepositHistoryResponse, error)
	// (ADMIN) DepositClaimInitPod accepts claim and pod from admin. Then initializes deposit claim
	// , enters trx_info and claim will be 'pod'
	DepositClaimInitPod(ctx context.Context, in *DepositClaimInitPodRequest, opts ...grpc.CallOption) (*DepositClaimInitPodResponse, error)
	// (ADMIN) UpdateDepositClaim updates deposit claim. It can be used for claim statuses,
	// 'aborted', 'not-conforming', 'pod', 'trx-ready', 'trx-ready-to-reconcile', 'cancelled'.
	UpdateDepositClaim(ctx context.Context, in *UpdateDepositClaimRequest, opts ...grpc.CallOption) (*UpdateDepositClaimResponse, error)
	// (ADMIN) DepositClaimReact changes deposit claim status from "pod", "approved", "cancelled" or "not-confroming"  to another
	DepositClaimReact(ctx context.Context, in *DepositClaimReactRequest, opts ...grpc.CallOption) (*DepositClaimReactResponse, error)
	// (ADMIN) DepositTransactionInit initializes deposit transaction with 'claim-approved' status
	// and based on specified actions finalize, confiscate or freeze the deposit transaction
	DepositTransactionInit(ctx context.Context, in *DepositTransactionInitRequest, opts ...grpc.CallOption) (*DepositTransactionInitResponse, error)
	// (ADMIN) DepositTransactionFinalize  finalizes deposit transaction with 'frozen' status
	DepositTransactionFinalize(ctx context.Context, in *DepositTransactionFinalizeRequest, opts ...grpc.CallOption) (*DepositTransactionFinalizeResponse, error)
	// (ADMIN) DepositTransactionFinalize  confiscates deposit transaction with 'frozen' status
	DepositTransactionConfiscate(ctx context.Context, in *DepositTransactionConfiscateRequest, opts ...grpc.CallOption) (*DepositTransactionConfiscateResponse, error)
	// (ADMIN) DepositTransactionSuspend  makes suspend deposit transactions
	DepositTransactionSuspend(ctx context.Context, in *DepositTransactionSuspendRequest, opts ...grpc.CallOption) (*DepositTransactionSuspendResponse, error)
	// (ADMIN) DepositClaimReconcileInit accepts claim and pod from admin. Then initializes deposit claim (type reconcilation).
	// Resulting status will be 'approved-to-reconcile' for further decision by admin.
	DepositClaimReconcileInit(ctx context.Context, in *DepositClaimReconcileInitRequest, opts ...grpc.CallOption) (*DepositClaimReconcileInitResponse, error)
	// (ADMIN) DepositClaimReconcile reconcile deposit transaction with 'approved-to-reconcile' status
	// and based on specified actions finalize, confiscate the deposit transaction
	DepositClaimReconcile(ctx context.Context, in *DepositClaimReconcileRequest, opts ...grpc.CallOption) (*DepositClaimReconcileResponse, error)
	// (ADMIN) DepositFilter
	DepositFilter(ctx context.Context, in *DepositFilterRequest, opts ...grpc.CallOption) (*DepositFilterResponse, error)
	// (ADMIN) DepositTransactionList
	DepositTransactionList(ctx context.Context, in *DepositTransactionListRequest, opts ...grpc.CallOption) (*DepositTransactionListResponse, error)
	// (ADMIN) DepositClaimList
	DepositClaimList(ctx context.Context, in *DepositClaimListRequest, opts ...grpc.CallOption) (*DepositClaimListResponse, error)
	// (ADMIN) DepositCommentCreate
	DepositCommentCreate(ctx context.Context, in *DepositCommentCreateRequest, opts ...grpc.CallOption) (*DepositCommentCreateResponse, error)
	// (ADMIN) DepositCommentList
	DepositCommentList(ctx context.Context, in *DepositCommentListRequest, opts ...grpc.CallOption) (*DepositCommentListResponse, error)
	// (Crypto-Gatway) DepositFullNodeInit
	DepositFullNodeInit(ctx context.Context, in *DepositFullNodeInitRequest, opts ...grpc.CallOption) (*DepositFullNodeInitResponse, error)
	// (Crypto-Gatway) DepositFullNodeConfirm confirms 'waiting for confirmation' trx
	DepositFullNodeConfirm(ctx context.Context, in *DepositFullNodeConfirmRequest, opts ...grpc.CallOption) (*DepositFullNodeConfirmResponse, error)
	// (Crypto-Gatway) DepositFullNodeCancel cancel 'waiting for confirmation' trx
	DepositFullNodeCancel(ctx context.Context, in *DepositFullNodeCancelRequest, opts ...grpc.CallOption) (*DepositFullNodeCancelResponse, error)
}

type cryptoDepositClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoDepositClient(cc grpc.ClientConnInterface) CryptoDepositClient {
	return &cryptoDepositClient{cc}
}

func (c *cryptoDepositClient) DepositClaimInit(ctx context.Context, in *DepositClaimInitRequest, opts ...grpc.CallOption) (*DepositClaimInitResponse, error) {
	out := new(DepositClaimInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositClaimInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositClaimPod(ctx context.Context, in *DepositClaimPodRequest, opts ...grpc.CallOption) (*DepositClaimPodResponse, error) {
	out := new(DepositClaimPodResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositClaimPod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositHistory(ctx context.Context, in *DepositHistoryRequest, opts ...grpc.CallOption) (*DepositHistoryResponse, error) {
	out := new(DepositHistoryResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositClaimInitPod(ctx context.Context, in *DepositClaimInitPodRequest, opts ...grpc.CallOption) (*DepositClaimInitPodResponse, error) {
	out := new(DepositClaimInitPodResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositClaimInitPod", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) UpdateDepositClaim(ctx context.Context, in *UpdateDepositClaimRequest, opts ...grpc.CallOption) (*UpdateDepositClaimResponse, error) {
	out := new(UpdateDepositClaimResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/UpdateDepositClaim", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositClaimReact(ctx context.Context, in *DepositClaimReactRequest, opts ...grpc.CallOption) (*DepositClaimReactResponse, error) {
	out := new(DepositClaimReactResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositClaimReact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositTransactionInit(ctx context.Context, in *DepositTransactionInitRequest, opts ...grpc.CallOption) (*DepositTransactionInitResponse, error) {
	out := new(DepositTransactionInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositTransactionFinalize(ctx context.Context, in *DepositTransactionFinalizeRequest, opts ...grpc.CallOption) (*DepositTransactionFinalizeResponse, error) {
	out := new(DepositTransactionFinalizeResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionFinalize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositTransactionConfiscate(ctx context.Context, in *DepositTransactionConfiscateRequest, opts ...grpc.CallOption) (*DepositTransactionConfiscateResponse, error) {
	out := new(DepositTransactionConfiscateResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionConfiscate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositTransactionSuspend(ctx context.Context, in *DepositTransactionSuspendRequest, opts ...grpc.CallOption) (*DepositTransactionSuspendResponse, error) {
	out := new(DepositTransactionSuspendResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionSuspend", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositClaimReconcileInit(ctx context.Context, in *DepositClaimReconcileInitRequest, opts ...grpc.CallOption) (*DepositClaimReconcileInitResponse, error) {
	out := new(DepositClaimReconcileInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositClaimReconcileInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositClaimReconcile(ctx context.Context, in *DepositClaimReconcileRequest, opts ...grpc.CallOption) (*DepositClaimReconcileResponse, error) {
	out := new(DepositClaimReconcileResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositClaimReconcile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositFilter(ctx context.Context, in *DepositFilterRequest, opts ...grpc.CallOption) (*DepositFilterResponse, error) {
	out := new(DepositFilterResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositTransactionList(ctx context.Context, in *DepositTransactionListRequest, opts ...grpc.CallOption) (*DepositTransactionListResponse, error) {
	out := new(DepositTransactionListResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositClaimList(ctx context.Context, in *DepositClaimListRequest, opts ...grpc.CallOption) (*DepositClaimListResponse, error) {
	out := new(DepositClaimListResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositClaimList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositCommentCreate(ctx context.Context, in *DepositCommentCreateRequest, opts ...grpc.CallOption) (*DepositCommentCreateResponse, error) {
	out := new(DepositCommentCreateResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositCommentCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositCommentList(ctx context.Context, in *DepositCommentListRequest, opts ...grpc.CallOption) (*DepositCommentListResponse, error) {
	out := new(DepositCommentListResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositCommentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositFullNodeInit(ctx context.Context, in *DepositFullNodeInitRequest, opts ...grpc.CallOption) (*DepositFullNodeInitResponse, error) {
	out := new(DepositFullNodeInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositFullNodeInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositFullNodeConfirm(ctx context.Context, in *DepositFullNodeConfirmRequest, opts ...grpc.CallOption) (*DepositFullNodeConfirmResponse, error) {
	out := new(DepositFullNodeConfirmResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositFullNodeConfirm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoDepositClient) DepositFullNodeCancel(ctx context.Context, in *DepositFullNodeCancelRequest, opts ...grpc.CallOption) (*DepositFullNodeCancelResponse, error) {
	out := new(DepositFullNodeCancelResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoDeposit/DepositFullNodeCancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoDepositServer is the server API for CryptoDeposit service.
// All implementations must embed UnimplementedCryptoDepositServer
// for forward compatibility
type CryptoDepositServer interface {
	// (USER) DepositClaimInit initializes deposit claim
	DepositClaimInit(context.Context, *DepositClaimInitRequest) (*DepositClaimInitResponse, error)
	// (USER) DepositClaimPod accepts proof of deposit from user
	DepositClaimPod(context.Context, *DepositClaimPodRequest) (*DepositClaimPodResponse, error)
	// (USER) DepositHistory
	DepositHistory(context.Context, *DepositHistoryRequest) (*DepositHistoryResponse, error)
	// (ADMIN) DepositClaimInitPod accepts claim and pod from admin. Then initializes deposit claim
	// , enters trx_info and claim will be 'pod'
	DepositClaimInitPod(context.Context, *DepositClaimInitPodRequest) (*DepositClaimInitPodResponse, error)
	// (ADMIN) UpdateDepositClaim updates deposit claim. It can be used for claim statuses,
	// 'aborted', 'not-conforming', 'pod', 'trx-ready', 'trx-ready-to-reconcile', 'cancelled'.
	UpdateDepositClaim(context.Context, *UpdateDepositClaimRequest) (*UpdateDepositClaimResponse, error)
	// (ADMIN) DepositClaimReact changes deposit claim status from "pod", "approved", "cancelled" or "not-confroming"  to another
	DepositClaimReact(context.Context, *DepositClaimReactRequest) (*DepositClaimReactResponse, error)
	// (ADMIN) DepositTransactionInit initializes deposit transaction with 'claim-approved' status
	// and based on specified actions finalize, confiscate or freeze the deposit transaction
	DepositTransactionInit(context.Context, *DepositTransactionInitRequest) (*DepositTransactionInitResponse, error)
	// (ADMIN) DepositTransactionFinalize  finalizes deposit transaction with 'frozen' status
	DepositTransactionFinalize(context.Context, *DepositTransactionFinalizeRequest) (*DepositTransactionFinalizeResponse, error)
	// (ADMIN) DepositTransactionFinalize  confiscates deposit transaction with 'frozen' status
	DepositTransactionConfiscate(context.Context, *DepositTransactionConfiscateRequest) (*DepositTransactionConfiscateResponse, error)
	// (ADMIN) DepositTransactionSuspend  makes suspend deposit transactions
	DepositTransactionSuspend(context.Context, *DepositTransactionSuspendRequest) (*DepositTransactionSuspendResponse, error)
	// (ADMIN) DepositClaimReconcileInit accepts claim and pod from admin. Then initializes deposit claim (type reconcilation).
	// Resulting status will be 'approved-to-reconcile' for further decision by admin.
	DepositClaimReconcileInit(context.Context, *DepositClaimReconcileInitRequest) (*DepositClaimReconcileInitResponse, error)
	// (ADMIN) DepositClaimReconcile reconcile deposit transaction with 'approved-to-reconcile' status
	// and based on specified actions finalize, confiscate the deposit transaction
	DepositClaimReconcile(context.Context, *DepositClaimReconcileRequest) (*DepositClaimReconcileResponse, error)
	// (ADMIN) DepositFilter
	DepositFilter(context.Context, *DepositFilterRequest) (*DepositFilterResponse, error)
	// (ADMIN) DepositTransactionList
	DepositTransactionList(context.Context, *DepositTransactionListRequest) (*DepositTransactionListResponse, error)
	// (ADMIN) DepositClaimList
	DepositClaimList(context.Context, *DepositClaimListRequest) (*DepositClaimListResponse, error)
	// (ADMIN) DepositCommentCreate
	DepositCommentCreate(context.Context, *DepositCommentCreateRequest) (*DepositCommentCreateResponse, error)
	// (ADMIN) DepositCommentList
	DepositCommentList(context.Context, *DepositCommentListRequest) (*DepositCommentListResponse, error)
	// (Crypto-Gatway) DepositFullNodeInit
	DepositFullNodeInit(context.Context, *DepositFullNodeInitRequest) (*DepositFullNodeInitResponse, error)
	// (Crypto-Gatway) DepositFullNodeConfirm confirms 'waiting for confirmation' trx
	DepositFullNodeConfirm(context.Context, *DepositFullNodeConfirmRequest) (*DepositFullNodeConfirmResponse, error)
	// (Crypto-Gatway) DepositFullNodeCancel cancel 'waiting for confirmation' trx
	DepositFullNodeCancel(context.Context, *DepositFullNodeCancelRequest) (*DepositFullNodeCancelResponse, error)
	mustEmbedUnimplementedCryptoDepositServer()
}

// UnimplementedCryptoDepositServer must be embedded to have forward compatible implementations.
type UnimplementedCryptoDepositServer struct {
}

func (UnimplementedCryptoDepositServer) DepositClaimInit(context.Context, *DepositClaimInitRequest) (*DepositClaimInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositClaimInit not implemented")
}
func (UnimplementedCryptoDepositServer) DepositClaimPod(context.Context, *DepositClaimPodRequest) (*DepositClaimPodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositClaimPod not implemented")
}
func (UnimplementedCryptoDepositServer) DepositHistory(context.Context, *DepositHistoryRequest) (*DepositHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositHistory not implemented")
}
func (UnimplementedCryptoDepositServer) DepositClaimInitPod(context.Context, *DepositClaimInitPodRequest) (*DepositClaimInitPodResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositClaimInitPod not implemented")
}
func (UnimplementedCryptoDepositServer) UpdateDepositClaim(context.Context, *UpdateDepositClaimRequest) (*UpdateDepositClaimResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDepositClaim not implemented")
}
func (UnimplementedCryptoDepositServer) DepositClaimReact(context.Context, *DepositClaimReactRequest) (*DepositClaimReactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositClaimReact not implemented")
}
func (UnimplementedCryptoDepositServer) DepositTransactionInit(context.Context, *DepositTransactionInitRequest) (*DepositTransactionInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositTransactionInit not implemented")
}
func (UnimplementedCryptoDepositServer) DepositTransactionFinalize(context.Context, *DepositTransactionFinalizeRequest) (*DepositTransactionFinalizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositTransactionFinalize not implemented")
}
func (UnimplementedCryptoDepositServer) DepositTransactionConfiscate(context.Context, *DepositTransactionConfiscateRequest) (*DepositTransactionConfiscateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositTransactionConfiscate not implemented")
}
func (UnimplementedCryptoDepositServer) DepositTransactionSuspend(context.Context, *DepositTransactionSuspendRequest) (*DepositTransactionSuspendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositTransactionSuspend not implemented")
}
func (UnimplementedCryptoDepositServer) DepositClaimReconcileInit(context.Context, *DepositClaimReconcileInitRequest) (*DepositClaimReconcileInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositClaimReconcileInit not implemented")
}
func (UnimplementedCryptoDepositServer) DepositClaimReconcile(context.Context, *DepositClaimReconcileRequest) (*DepositClaimReconcileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositClaimReconcile not implemented")
}
func (UnimplementedCryptoDepositServer) DepositFilter(context.Context, *DepositFilterRequest) (*DepositFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositFilter not implemented")
}
func (UnimplementedCryptoDepositServer) DepositTransactionList(context.Context, *DepositTransactionListRequest) (*DepositTransactionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositTransactionList not implemented")
}
func (UnimplementedCryptoDepositServer) DepositClaimList(context.Context, *DepositClaimListRequest) (*DepositClaimListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositClaimList not implemented")
}
func (UnimplementedCryptoDepositServer) DepositCommentCreate(context.Context, *DepositCommentCreateRequest) (*DepositCommentCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositCommentCreate not implemented")
}
func (UnimplementedCryptoDepositServer) DepositCommentList(context.Context, *DepositCommentListRequest) (*DepositCommentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositCommentList not implemented")
}
func (UnimplementedCryptoDepositServer) DepositFullNodeInit(context.Context, *DepositFullNodeInitRequest) (*DepositFullNodeInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositFullNodeInit not implemented")
}
func (UnimplementedCryptoDepositServer) DepositFullNodeConfirm(context.Context, *DepositFullNodeConfirmRequest) (*DepositFullNodeConfirmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositFullNodeConfirm not implemented")
}
func (UnimplementedCryptoDepositServer) DepositFullNodeCancel(context.Context, *DepositFullNodeCancelRequest) (*DepositFullNodeCancelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositFullNodeCancel not implemented")
}
func (UnimplementedCryptoDepositServer) mustEmbedUnimplementedCryptoDepositServer() {}

// UnsafeCryptoDepositServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoDepositServer will
// result in compilation errors.
type UnsafeCryptoDepositServer interface {
	mustEmbedUnimplementedCryptoDepositServer()
}

func RegisterCryptoDepositServer(s grpc.ServiceRegistrar, srv CryptoDepositServer) {
	s.RegisterService(&CryptoDeposit_ServiceDesc, srv)
}

func _CryptoDeposit_DepositClaimInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositClaimInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositClaimInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositClaimInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositClaimInit(ctx, req.(*DepositClaimInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositClaimPod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositClaimPodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositClaimPod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositClaimPod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositClaimPod(ctx, req.(*DepositClaimPodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositHistory(ctx, req.(*DepositHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositClaimInitPod_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositClaimInitPodRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositClaimInitPod(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositClaimInitPod",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositClaimInitPod(ctx, req.(*DepositClaimInitPodRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_UpdateDepositClaim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDepositClaimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).UpdateDepositClaim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/UpdateDepositClaim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).UpdateDepositClaim(ctx, req.(*UpdateDepositClaimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositClaimReact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositClaimReactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositClaimReact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositClaimReact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositClaimReact(ctx, req.(*DepositClaimReactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositTransactionInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositTransactionInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositTransactionInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositTransactionInit(ctx, req.(*DepositTransactionInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositTransactionFinalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositTransactionFinalizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositTransactionFinalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionFinalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositTransactionFinalize(ctx, req.(*DepositTransactionFinalizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositTransactionConfiscate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositTransactionConfiscateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositTransactionConfiscate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionConfiscate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositTransactionConfiscate(ctx, req.(*DepositTransactionConfiscateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositTransactionSuspend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositTransactionSuspendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositTransactionSuspend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionSuspend",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositTransactionSuspend(ctx, req.(*DepositTransactionSuspendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositClaimReconcileInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositClaimReconcileInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositClaimReconcileInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositClaimReconcileInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositClaimReconcileInit(ctx, req.(*DepositClaimReconcileInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositClaimReconcile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositClaimReconcileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositClaimReconcile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositClaimReconcile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositClaimReconcile(ctx, req.(*DepositClaimReconcileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositFilter(ctx, req.(*DepositFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositTransactionList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositTransactionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositTransactionList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositTransactionList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositTransactionList(ctx, req.(*DepositTransactionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositClaimList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositClaimListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositClaimList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositClaimList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositClaimList(ctx, req.(*DepositClaimListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositCommentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositCommentCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositCommentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositCommentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositCommentCreate(ctx, req.(*DepositCommentCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositCommentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositCommentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositCommentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositCommentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositCommentList(ctx, req.(*DepositCommentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositFullNodeInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositFullNodeInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositFullNodeInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositFullNodeInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositFullNodeInit(ctx, req.(*DepositFullNodeInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositFullNodeConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositFullNodeConfirmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositFullNodeConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositFullNodeConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositFullNodeConfirm(ctx, req.(*DepositFullNodeConfirmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoDeposit_DepositFullNodeCancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositFullNodeCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoDepositServer).DepositFullNodeCancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoDeposit/DepositFullNodeCancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoDepositServer).DepositFullNodeCancel(ctx, req.(*DepositFullNodeCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptoDeposit_ServiceDesc is the grpc.ServiceDesc for CryptoDeposit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoDeposit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "financialCoordinator.crypto.CryptoDeposit",
	HandlerType: (*CryptoDepositServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DepositClaimInit",
			Handler:    _CryptoDeposit_DepositClaimInit_Handler,
		},
		{
			MethodName: "DepositClaimPod",
			Handler:    _CryptoDeposit_DepositClaimPod_Handler,
		},
		{
			MethodName: "DepositHistory",
			Handler:    _CryptoDeposit_DepositHistory_Handler,
		},
		{
			MethodName: "DepositClaimInitPod",
			Handler:    _CryptoDeposit_DepositClaimInitPod_Handler,
		},
		{
			MethodName: "UpdateDepositClaim",
			Handler:    _CryptoDeposit_UpdateDepositClaim_Handler,
		},
		{
			MethodName: "DepositClaimReact",
			Handler:    _CryptoDeposit_DepositClaimReact_Handler,
		},
		{
			MethodName: "DepositTransactionInit",
			Handler:    _CryptoDeposit_DepositTransactionInit_Handler,
		},
		{
			MethodName: "DepositTransactionFinalize",
			Handler:    _CryptoDeposit_DepositTransactionFinalize_Handler,
		},
		{
			MethodName: "DepositTransactionConfiscate",
			Handler:    _CryptoDeposit_DepositTransactionConfiscate_Handler,
		},
		{
			MethodName: "DepositTransactionSuspend",
			Handler:    _CryptoDeposit_DepositTransactionSuspend_Handler,
		},
		{
			MethodName: "DepositClaimReconcileInit",
			Handler:    _CryptoDeposit_DepositClaimReconcileInit_Handler,
		},
		{
			MethodName: "DepositClaimReconcile",
			Handler:    _CryptoDeposit_DepositClaimReconcile_Handler,
		},
		{
			MethodName: "DepositFilter",
			Handler:    _CryptoDeposit_DepositFilter_Handler,
		},
		{
			MethodName: "DepositTransactionList",
			Handler:    _CryptoDeposit_DepositTransactionList_Handler,
		},
		{
			MethodName: "DepositClaimList",
			Handler:    _CryptoDeposit_DepositClaimList_Handler,
		},
		{
			MethodName: "DepositCommentCreate",
			Handler:    _CryptoDeposit_DepositCommentCreate_Handler,
		},
		{
			MethodName: "DepositCommentList",
			Handler:    _CryptoDeposit_DepositCommentList_Handler,
		},
		{
			MethodName: "DepositFullNodeInit",
			Handler:    _CryptoDeposit_DepositFullNodeInit_Handler,
		},
		{
			MethodName: "DepositFullNodeConfirm",
			Handler:    _CryptoDeposit_DepositFullNodeConfirm_Handler,
		},
		{
			MethodName: "DepositFullNodeCancel",
			Handler:    _CryptoDeposit_DepositFullNodeCancel_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "financial-coordinator/crypto/services.proto",
}

// CryptoWithdrawClient is the client API for CryptoWithdraw service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptoWithdrawClient interface {
	// (USER) WithdrawInit initializes withdraw request
	WithdrawInit(ctx context.Context, in *WithdrawInitRequest, opts ...grpc.CallOption) (*WithdrawInitResponse, error)
	// (USER) WithdrawHistory
	WithdrawHistory(ctx context.Context, in *WithdrawHistoryRequest, opts ...grpc.CallOption) (*WithdrawHistoryResponse, error)
	// (ADMIN) WithdrawFilter
	WithdrawFilter(ctx context.Context, in *WithdrawFilterRequest, opts ...grpc.CallOption) (*WithdrawFilterResponse, error)
	// (ADMIN) WithdrawManualInit initializes withdraw request
	// reuslting status will be 'waiting for admin'
	WithdrawManualInit(ctx context.Context, in *WithdrawManualInitRequest, opts ...grpc.CallOption) (*WithdrawManualInitResponse, error)
	// (ADMIN) WithdrawProceed takes aciton on Withdraw  transaciton
	// Only works for 'waiting for admin', 'miscarried' or 'frozen' trxs
	WithdrawProceed(ctx context.Context, in *WithdrawProceedRequest, opts ...grpc.CallOption) (*WithdrawProceedResponse, error)
	// (ADMIN) WithdrawSettlementDeclare gets service provid xid from admin and finalize to accounting base on it.
	// Only works for 'waiting for admin', 'miscarried', 'acc-finalize-failed' or 'frozen' trxs
	WithdrawSettlementDeclare(ctx context.Context, in *WithdrawSettlementDeclareRequest, opts ...grpc.CallOption) (*WithdrawSettlementDeclareResponse, error)
	// (ADMIN) WithdrawCompletenessDeclare gets txid from admin and completes the trx. Only 'successful' trx.
	WithdrawCompletenessDeclare(ctx context.Context, in *WithdrawCompletenessDeclareRequest, opts ...grpc.CallOption) (*WithdrawCompletenessDeclareResponse, error)
	// (ADMIN) WithdrawMakeCorrective reverts a withdraw transaction.
	// Only works for 'successful' or 'completed' trxs
	WithdrawMakeCorrective(ctx context.Context, in *WithdrawMakeCorrectiveRequest, opts ...grpc.CallOption) (*WithdrawMakeCorrectiveResponse, error)
	// (ADMIN) WithdrawCommentCreate
	WithdrawCommentCreate(ctx context.Context, in *WithdrawCommentCreateRequest, opts ...grpc.CallOption) (*WithdrawCommentCreateResponse, error)
	// (ADMIN) WithdrawCommentList
	WithdrawCommentList(ctx context.Context, in *WithdrawCommentListRequest, opts ...grpc.CallOption) (*WithdrawCommentListResponse, error)
}

type cryptoWithdrawClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptoWithdrawClient(cc grpc.ClientConnInterface) CryptoWithdrawClient {
	return &cryptoWithdrawClient{cc}
}

func (c *cryptoWithdrawClient) WithdrawInit(ctx context.Context, in *WithdrawInitRequest, opts ...grpc.CallOption) (*WithdrawInitResponse, error) {
	out := new(WithdrawInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawHistory(ctx context.Context, in *WithdrawHistoryRequest, opts ...grpc.CallOption) (*WithdrawHistoryResponse, error) {
	out := new(WithdrawHistoryResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawFilter(ctx context.Context, in *WithdrawFilterRequest, opts ...grpc.CallOption) (*WithdrawFilterResponse, error) {
	out := new(WithdrawFilterResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawManualInit(ctx context.Context, in *WithdrawManualInitRequest, opts ...grpc.CallOption) (*WithdrawManualInitResponse, error) {
	out := new(WithdrawManualInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawManualInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawProceed(ctx context.Context, in *WithdrawProceedRequest, opts ...grpc.CallOption) (*WithdrawProceedResponse, error) {
	out := new(WithdrawProceedResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawProceed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawSettlementDeclare(ctx context.Context, in *WithdrawSettlementDeclareRequest, opts ...grpc.CallOption) (*WithdrawSettlementDeclareResponse, error) {
	out := new(WithdrawSettlementDeclareResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawSettlementDeclare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawCompletenessDeclare(ctx context.Context, in *WithdrawCompletenessDeclareRequest, opts ...grpc.CallOption) (*WithdrawCompletenessDeclareResponse, error) {
	out := new(WithdrawCompletenessDeclareResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawCompletenessDeclare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawMakeCorrective(ctx context.Context, in *WithdrawMakeCorrectiveRequest, opts ...grpc.CallOption) (*WithdrawMakeCorrectiveResponse, error) {
	out := new(WithdrawMakeCorrectiveResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawMakeCorrective", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawCommentCreate(ctx context.Context, in *WithdrawCommentCreateRequest, opts ...grpc.CallOption) (*WithdrawCommentCreateResponse, error) {
	out := new(WithdrawCommentCreateResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawCommentCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptoWithdrawClient) WithdrawCommentList(ctx context.Context, in *WithdrawCommentListRequest, opts ...grpc.CallOption) (*WithdrawCommentListResponse, error) {
	out := new(WithdrawCommentListResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.crypto.CryptoWithdraw/WithdrawCommentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptoWithdrawServer is the server API for CryptoWithdraw service.
// All implementations must embed UnimplementedCryptoWithdrawServer
// for forward compatibility
type CryptoWithdrawServer interface {
	// (USER) WithdrawInit initializes withdraw request
	WithdrawInit(context.Context, *WithdrawInitRequest) (*WithdrawInitResponse, error)
	// (USER) WithdrawHistory
	WithdrawHistory(context.Context, *WithdrawHistoryRequest) (*WithdrawHistoryResponse, error)
	// (ADMIN) WithdrawFilter
	WithdrawFilter(context.Context, *WithdrawFilterRequest) (*WithdrawFilterResponse, error)
	// (ADMIN) WithdrawManualInit initializes withdraw request
	// reuslting status will be 'waiting for admin'
	WithdrawManualInit(context.Context, *WithdrawManualInitRequest) (*WithdrawManualInitResponse, error)
	// (ADMIN) WithdrawProceed takes aciton on Withdraw  transaciton
	// Only works for 'waiting for admin', 'miscarried' or 'frozen' trxs
	WithdrawProceed(context.Context, *WithdrawProceedRequest) (*WithdrawProceedResponse, error)
	// (ADMIN) WithdrawSettlementDeclare gets service provid xid from admin and finalize to accounting base on it.
	// Only works for 'waiting for admin', 'miscarried', 'acc-finalize-failed' or 'frozen' trxs
	WithdrawSettlementDeclare(context.Context, *WithdrawSettlementDeclareRequest) (*WithdrawSettlementDeclareResponse, error)
	// (ADMIN) WithdrawCompletenessDeclare gets txid from admin and completes the trx. Only 'successful' trx.
	WithdrawCompletenessDeclare(context.Context, *WithdrawCompletenessDeclareRequest) (*WithdrawCompletenessDeclareResponse, error)
	// (ADMIN) WithdrawMakeCorrective reverts a withdraw transaction.
	// Only works for 'successful' or 'completed' trxs
	WithdrawMakeCorrective(context.Context, *WithdrawMakeCorrectiveRequest) (*WithdrawMakeCorrectiveResponse, error)
	// (ADMIN) WithdrawCommentCreate
	WithdrawCommentCreate(context.Context, *WithdrawCommentCreateRequest) (*WithdrawCommentCreateResponse, error)
	// (ADMIN) WithdrawCommentList
	WithdrawCommentList(context.Context, *WithdrawCommentListRequest) (*WithdrawCommentListResponse, error)
	mustEmbedUnimplementedCryptoWithdrawServer()
}

// UnimplementedCryptoWithdrawServer must be embedded to have forward compatible implementations.
type UnimplementedCryptoWithdrawServer struct {
}

func (UnimplementedCryptoWithdrawServer) WithdrawInit(context.Context, *WithdrawInitRequest) (*WithdrawInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawInit not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawHistory(context.Context, *WithdrawHistoryRequest) (*WithdrawHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawHistory not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawFilter(context.Context, *WithdrawFilterRequest) (*WithdrawFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawFilter not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawManualInit(context.Context, *WithdrawManualInitRequest) (*WithdrawManualInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawManualInit not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawProceed(context.Context, *WithdrawProceedRequest) (*WithdrawProceedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawProceed not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawSettlementDeclare(context.Context, *WithdrawSettlementDeclareRequest) (*WithdrawSettlementDeclareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawSettlementDeclare not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawCompletenessDeclare(context.Context, *WithdrawCompletenessDeclareRequest) (*WithdrawCompletenessDeclareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawCompletenessDeclare not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawMakeCorrective(context.Context, *WithdrawMakeCorrectiveRequest) (*WithdrawMakeCorrectiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawMakeCorrective not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawCommentCreate(context.Context, *WithdrawCommentCreateRequest) (*WithdrawCommentCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawCommentCreate not implemented")
}
func (UnimplementedCryptoWithdrawServer) WithdrawCommentList(context.Context, *WithdrawCommentListRequest) (*WithdrawCommentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawCommentList not implemented")
}
func (UnimplementedCryptoWithdrawServer) mustEmbedUnimplementedCryptoWithdrawServer() {}

// UnsafeCryptoWithdrawServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptoWithdrawServer will
// result in compilation errors.
type UnsafeCryptoWithdrawServer interface {
	mustEmbedUnimplementedCryptoWithdrawServer()
}

func RegisterCryptoWithdrawServer(s grpc.ServiceRegistrar, srv CryptoWithdrawServer) {
	s.RegisterService(&CryptoWithdraw_ServiceDesc, srv)
}

func _CryptoWithdraw_WithdrawInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawInit(ctx, req.(*WithdrawInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawHistory(ctx, req.(*WithdrawHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawFilter(ctx, req.(*WithdrawFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawManualInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawManualInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawManualInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawManualInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawManualInit(ctx, req.(*WithdrawManualInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawProceed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawProceedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawProceed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawProceed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawProceed(ctx, req.(*WithdrawProceedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawSettlementDeclare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawSettlementDeclareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawSettlementDeclare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawSettlementDeclare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawSettlementDeclare(ctx, req.(*WithdrawSettlementDeclareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawCompletenessDeclare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawCompletenessDeclareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawCompletenessDeclare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawCompletenessDeclare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawCompletenessDeclare(ctx, req.(*WithdrawCompletenessDeclareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawMakeCorrective_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMakeCorrectiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawMakeCorrective(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawMakeCorrective",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawMakeCorrective(ctx, req.(*WithdrawMakeCorrectiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawCommentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawCommentCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawCommentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawCommentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawCommentCreate(ctx, req.(*WithdrawCommentCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptoWithdraw_WithdrawCommentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawCommentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptoWithdrawServer).WithdrawCommentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.crypto.CryptoWithdraw/WithdrawCommentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptoWithdrawServer).WithdrawCommentList(ctx, req.(*WithdrawCommentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptoWithdraw_ServiceDesc is the grpc.ServiceDesc for CryptoWithdraw service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptoWithdraw_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "financialCoordinator.crypto.CryptoWithdraw",
	HandlerType: (*CryptoWithdrawServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WithdrawInit",
			Handler:    _CryptoWithdraw_WithdrawInit_Handler,
		},
		{
			MethodName: "WithdrawHistory",
			Handler:    _CryptoWithdraw_WithdrawHistory_Handler,
		},
		{
			MethodName: "WithdrawFilter",
			Handler:    _CryptoWithdraw_WithdrawFilter_Handler,
		},
		{
			MethodName: "WithdrawManualInit",
			Handler:    _CryptoWithdraw_WithdrawManualInit_Handler,
		},
		{
			MethodName: "WithdrawProceed",
			Handler:    _CryptoWithdraw_WithdrawProceed_Handler,
		},
		{
			MethodName: "WithdrawSettlementDeclare",
			Handler:    _CryptoWithdraw_WithdrawSettlementDeclare_Handler,
		},
		{
			MethodName: "WithdrawCompletenessDeclare",
			Handler:    _CryptoWithdraw_WithdrawCompletenessDeclare_Handler,
		},
		{
			MethodName: "WithdrawMakeCorrective",
			Handler:    _CryptoWithdraw_WithdrawMakeCorrective_Handler,
		},
		{
			MethodName: "WithdrawCommentCreate",
			Handler:    _CryptoWithdraw_WithdrawCommentCreate_Handler,
		},
		{
			MethodName: "WithdrawCommentList",
			Handler:    _CryptoWithdraw_WithdrawCommentList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "financial-coordinator/crypto/services.proto",
}
