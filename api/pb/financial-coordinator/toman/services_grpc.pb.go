// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: financial-coordinator/toman/services.proto

package toman

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TomanDepositClient is the client API for TomanDeposit service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TomanDepositClient interface {
	// (USER) DepositInit initializes deposit request
	DepositInit(ctx context.Context, in *DepositInitRequest, opts ...grpc.CallOption) (*DepositInitResponse, error)
	// (USER) DepositHistory
	DepositHistory(ctx context.Context, in *DepositHistoryRequest, opts ...grpc.CallOption) (*DepositHistoryResponse, error)
	// (USER) Callback; front-end will call this endpoint
	// when user was redirected to FE by pyament service (IPG)
	// resulting status will be 'failed', 'completed' or 'waiting for admin'
	DepositCallback(ctx context.Context, in *DepositCallbackRequest, opts ...grpc.CallOption) (*DepositCallbackResponse, error)
	// (FIAT-GW) DepositVerify verifies if deposit is valid
	// (does the sanity checks and also checks whether trx is aborted or not)
	DepositVerify(ctx context.Context, in *DepositVerifyRequest, opts ...grpc.CallOption) (*DepositVerifyResponse, error)
	// (FIAT-GW) DepositTrxInit initializes a deposit trx
	// (checks for waiting for admin and does asociated accouting)
	DepositTrxInit(ctx context.Context, in *DepositTrxInitRequest, opts ...grpc.CallOption) (*DepositTrxInitResponse, error)
	// (ADMIN) DepositProceed takes aciton on deposit  transaciton
	// Only works for 'waiting for admin' or 'frozen' trxs
	DepositProceed(ctx context.Context, in *DepositProceedRequest, opts ...grpc.CallOption) (*DepositProceedResponse, error)
	// (ADMIN) DepositManual creates a deposit transaciton
	DepositManual(ctx context.Context, in *DepositManualRequest, opts ...grpc.CallOption) (*DepositManualResponse, error)
	// (ADMIN) DepositDeclare change 'failed' or 'payment successful manual' deposits to 'waiting for admin'
	DepositDeclare(ctx context.Context, in *DepositDeclareRequest, opts ...grpc.CallOption) (*DepositDeclareResponse, error)
	// (ADMIN) DepositCommentCreate
	DepositCommentCreate(ctx context.Context, in *DepositCommentCreateRequest, opts ...grpc.CallOption) (*DepositCommentCreateResponse, error)
	// (ADMIN) DepositCommentList
	DepositCommentList(ctx context.Context, in *DepositCommentListRequest, opts ...grpc.CallOption) (*DepositCommentListResponse, error)
	// (ADMIN) DepositFilter
	DepositFilter(ctx context.Context, in *DepositFilterRequest, opts ...grpc.CallOption) (*DepositFilterResponse, error)
}

type tomanDepositClient struct {
	cc grpc.ClientConnInterface
}

func NewTomanDepositClient(cc grpc.ClientConnInterface) TomanDepositClient {
	return &tomanDepositClient{cc}
}

func (c *tomanDepositClient) DepositInit(ctx context.Context, in *DepositInitRequest, opts ...grpc.CallOption) (*DepositInitResponse, error) {
	out := new(DepositInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositHistory(ctx context.Context, in *DepositHistoryRequest, opts ...grpc.CallOption) (*DepositHistoryResponse, error) {
	out := new(DepositHistoryResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositCallback(ctx context.Context, in *DepositCallbackRequest, opts ...grpc.CallOption) (*DepositCallbackResponse, error) {
	out := new(DepositCallbackResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositCallback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositVerify(ctx context.Context, in *DepositVerifyRequest, opts ...grpc.CallOption) (*DepositVerifyResponse, error) {
	out := new(DepositVerifyResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositVerify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositTrxInit(ctx context.Context, in *DepositTrxInitRequest, opts ...grpc.CallOption) (*DepositTrxInitResponse, error) {
	out := new(DepositTrxInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositTrxInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositProceed(ctx context.Context, in *DepositProceedRequest, opts ...grpc.CallOption) (*DepositProceedResponse, error) {
	out := new(DepositProceedResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositProceed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositManual(ctx context.Context, in *DepositManualRequest, opts ...grpc.CallOption) (*DepositManualResponse, error) {
	out := new(DepositManualResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositManual", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositDeclare(ctx context.Context, in *DepositDeclareRequest, opts ...grpc.CallOption) (*DepositDeclareResponse, error) {
	out := new(DepositDeclareResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositDeclare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositCommentCreate(ctx context.Context, in *DepositCommentCreateRequest, opts ...grpc.CallOption) (*DepositCommentCreateResponse, error) {
	out := new(DepositCommentCreateResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositCommentCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositCommentList(ctx context.Context, in *DepositCommentListRequest, opts ...grpc.CallOption) (*DepositCommentListResponse, error) {
	out := new(DepositCommentListResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositCommentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanDepositClient) DepositFilter(ctx context.Context, in *DepositFilterRequest, opts ...grpc.CallOption) (*DepositFilterResponse, error) {
	out := new(DepositFilterResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanDeposit/DepositFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TomanDepositServer is the server API for TomanDeposit service.
// All implementations must embed UnimplementedTomanDepositServer
// for forward compatibility
type TomanDepositServer interface {
	// (USER) DepositInit initializes deposit request
	DepositInit(context.Context, *DepositInitRequest) (*DepositInitResponse, error)
	// (USER) DepositHistory
	DepositHistory(context.Context, *DepositHistoryRequest) (*DepositHistoryResponse, error)
	// (USER) Callback; front-end will call this endpoint
	// when user was redirected to FE by pyament service (IPG)
	// resulting status will be 'failed', 'completed' or 'waiting for admin'
	DepositCallback(context.Context, *DepositCallbackRequest) (*DepositCallbackResponse, error)
	// (FIAT-GW) DepositVerify verifies if deposit is valid
	// (does the sanity checks and also checks whether trx is aborted or not)
	DepositVerify(context.Context, *DepositVerifyRequest) (*DepositVerifyResponse, error)
	// (FIAT-GW) DepositTrxInit initializes a deposit trx
	// (checks for waiting for admin and does asociated accouting)
	DepositTrxInit(context.Context, *DepositTrxInitRequest) (*DepositTrxInitResponse, error)
	// (ADMIN) DepositProceed takes aciton on deposit  transaciton
	// Only works for 'waiting for admin' or 'frozen' trxs
	DepositProceed(context.Context, *DepositProceedRequest) (*DepositProceedResponse, error)
	// (ADMIN) DepositManual creates a deposit transaciton
	DepositManual(context.Context, *DepositManualRequest) (*DepositManualResponse, error)
	// (ADMIN) DepositDeclare change 'failed' or 'payment successful manual' deposits to 'waiting for admin'
	DepositDeclare(context.Context, *DepositDeclareRequest) (*DepositDeclareResponse, error)
	// (ADMIN) DepositCommentCreate
	DepositCommentCreate(context.Context, *DepositCommentCreateRequest) (*DepositCommentCreateResponse, error)
	// (ADMIN) DepositCommentList
	DepositCommentList(context.Context, *DepositCommentListRequest) (*DepositCommentListResponse, error)
	// (ADMIN) DepositFilter
	DepositFilter(context.Context, *DepositFilterRequest) (*DepositFilterResponse, error)
	mustEmbedUnimplementedTomanDepositServer()
}

// UnimplementedTomanDepositServer must be embedded to have forward compatible implementations.
type UnimplementedTomanDepositServer struct {
}

func (UnimplementedTomanDepositServer) DepositInit(context.Context, *DepositInitRequest) (*DepositInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositInit not implemented")
}
func (UnimplementedTomanDepositServer) DepositHistory(context.Context, *DepositHistoryRequest) (*DepositHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositHistory not implemented")
}
func (UnimplementedTomanDepositServer) DepositCallback(context.Context, *DepositCallbackRequest) (*DepositCallbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositCallback not implemented")
}
func (UnimplementedTomanDepositServer) DepositVerify(context.Context, *DepositVerifyRequest) (*DepositVerifyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositVerify not implemented")
}
func (UnimplementedTomanDepositServer) DepositTrxInit(context.Context, *DepositTrxInitRequest) (*DepositTrxInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositTrxInit not implemented")
}
func (UnimplementedTomanDepositServer) DepositProceed(context.Context, *DepositProceedRequest) (*DepositProceedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositProceed not implemented")
}
func (UnimplementedTomanDepositServer) DepositManual(context.Context, *DepositManualRequest) (*DepositManualResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositManual not implemented")
}
func (UnimplementedTomanDepositServer) DepositDeclare(context.Context, *DepositDeclareRequest) (*DepositDeclareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositDeclare not implemented")
}
func (UnimplementedTomanDepositServer) DepositCommentCreate(context.Context, *DepositCommentCreateRequest) (*DepositCommentCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositCommentCreate not implemented")
}
func (UnimplementedTomanDepositServer) DepositCommentList(context.Context, *DepositCommentListRequest) (*DepositCommentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositCommentList not implemented")
}
func (UnimplementedTomanDepositServer) DepositFilter(context.Context, *DepositFilterRequest) (*DepositFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DepositFilter not implemented")
}
func (UnimplementedTomanDepositServer) mustEmbedUnimplementedTomanDepositServer() {}

// UnsafeTomanDepositServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TomanDepositServer will
// result in compilation errors.
type UnsafeTomanDepositServer interface {
	mustEmbedUnimplementedTomanDepositServer()
}

func RegisterTomanDepositServer(s grpc.ServiceRegistrar, srv TomanDepositServer) {
	s.RegisterService(&TomanDeposit_ServiceDesc, srv)
}

func _TomanDeposit_DepositInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositInit(ctx, req.(*DepositInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositHistory(ctx, req.(*DepositHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositCallback(ctx, req.(*DepositCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositVerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositVerify(ctx, req.(*DepositVerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositTrxInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositTrxInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositTrxInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositTrxInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositTrxInit(ctx, req.(*DepositTrxInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositProceed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositProceedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositProceed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositProceed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositProceed(ctx, req.(*DepositProceedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositManual_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositManualRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositManual(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositManual",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositManual(ctx, req.(*DepositManualRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositDeclare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositDeclareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositDeclare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositDeclare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositDeclare(ctx, req.(*DepositDeclareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositCommentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositCommentCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositCommentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositCommentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositCommentCreate(ctx, req.(*DepositCommentCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositCommentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositCommentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositCommentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositCommentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositCommentList(ctx, req.(*DepositCommentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanDeposit_DepositFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepositFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanDepositServer).DepositFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanDeposit/DepositFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanDepositServer).DepositFilter(ctx, req.(*DepositFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TomanDeposit_ServiceDesc is the grpc.ServiceDesc for TomanDeposit service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TomanDeposit_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "financialCoordinator.toman.TomanDeposit",
	HandlerType: (*TomanDepositServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DepositInit",
			Handler:    _TomanDeposit_DepositInit_Handler,
		},
		{
			MethodName: "DepositHistory",
			Handler:    _TomanDeposit_DepositHistory_Handler,
		},
		{
			MethodName: "DepositCallback",
			Handler:    _TomanDeposit_DepositCallback_Handler,
		},
		{
			MethodName: "DepositVerify",
			Handler:    _TomanDeposit_DepositVerify_Handler,
		},
		{
			MethodName: "DepositTrxInit",
			Handler:    _TomanDeposit_DepositTrxInit_Handler,
		},
		{
			MethodName: "DepositProceed",
			Handler:    _TomanDeposit_DepositProceed_Handler,
		},
		{
			MethodName: "DepositManual",
			Handler:    _TomanDeposit_DepositManual_Handler,
		},
		{
			MethodName: "DepositDeclare",
			Handler:    _TomanDeposit_DepositDeclare_Handler,
		},
		{
			MethodName: "DepositCommentCreate",
			Handler:    _TomanDeposit_DepositCommentCreate_Handler,
		},
		{
			MethodName: "DepositCommentList",
			Handler:    _TomanDeposit_DepositCommentList_Handler,
		},
		{
			MethodName: "DepositFilter",
			Handler:    _TomanDeposit_DepositFilter_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "financial-coordinator/toman/services.proto",
}

// TomanWithdrawClient is the client API for TomanWithdraw service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TomanWithdrawClient interface {
	// (USER) WithdrawTrxInit initializes withdraw request
	WithdrawTrxInit(ctx context.Context, in *WithdrawTrxInitRequest, opts ...grpc.CallOption) (*WithdrawTrxInitResponse, error)
	// (USER) WithdrawHistory
	WithdrawHistory(ctx context.Context, in *WithdrawHistoryRequest, opts ...grpc.CallOption) (*WithdrawHistoryResponse, error)
	// (ADMIN) WithdrawManualInit initializes withdraw request
	// reuslting status will be 'waiting for admin'
	WithdrawManualInit(ctx context.Context, in *WithdrawManualInitRequest, opts ...grpc.CallOption) (*WithdrawManualInitResponse, error)
	// (ADMIN) WithdrawProceed takes aciton on Withdraw  transaciton
	// Only works for 'waiting for admin', 'miscarried' or 'frozen' trxs
	WithdrawProceed(ctx context.Context, in *WithdrawProceedRequest, opts ...grpc.CallOption) (*WithdrawProceedResponse, error)
	// (ADMIN) DepositFilter
	WithdrawFilter(ctx context.Context, in *WithdrawFilterRequest, opts ...grpc.CallOption) (*WithdrawFilterResponse, error)
	// (FIAT-GW) WithdrawTrxFinalize insert fills related to withdraw trx into db
	// and finalizes with accounting.
	// resulting status would be 'successful'
	WithdrawTrxFinalize(ctx context.Context, in *WithdrawTrxFinalizeRequest, opts ...grpc.CallOption) (*WithdrawTrxFinalizeResponse, error)
	// (FIAT-GW) WithdrawNotifySuccess insert fills related to withdraw trx into db
	// and finalizes with accounting.
	// resulting status would be 'successful'
	WithdrawNotifySuccess(ctx context.Context, in *WithdrawNotifySuccessRequest, opts ...grpc.CallOption) (*WithdrawNotifySuccessResponse, error)
	// (FIAT-GW) WithdrawNotifyFailure updates withdraw trx.
	// resulting status would be 'miscarried'
	WithdrawNotifyFailure(ctx context.Context, in *WithdrawNotifyFailureRequest, opts ...grpc.CallOption) (*WithdrawNotifyFailureResponse, error)
	// (FIAT-GW) WithdrawTrxFill update fills with RRNs
	WithdrawTrxFill(ctx context.Context, in *WithdrawTrxFillRequest, opts ...grpc.CallOption) (*WithdrawTrxFillResponse, error)
	// (ADMIN) WithdrawSettlementDeclare gets settlement info from admin and finalize to accounting based on it.
	// Only works for 'waiting for admin', 'miscarried', 'acc-finalize-failed' or 'frozen' trxs
	WithdrawSettlementDeclare(ctx context.Context, in *WithdrawSettlementDeclareRequest, opts ...grpc.CallOption) (*WithdrawSettlementDeclareResponse, error)
	// (ADMIN) WithdrawCompletenessDeclare gets RRNs from admin and updates the trx fills.
	// Only 'successful' trx.
	// resulting status would be 'completed'
	// it can be used for 'completed' trxs to update fills.
	WithdrawCompletenessDeclare(ctx context.Context, in *WithdrawCompletenessDeclareRequest, opts ...grpc.CallOption) (*WithdrawCompletenessDeclareResponse, error)
	// (ADMIN) WithdrawMakeCorrective reverts a withdraw transaction.
	// Only works for 'successful' or 'completed' trxs
	WithdrawMakeCorrective(ctx context.Context, in *WithdrawMakeCorrectiveRequest, opts ...grpc.CallOption) (*WithdrawMakeCorrectiveResponse, error)
	// (ADMIN) WithdrawCommentCreate
	WithdrawCommentCreate(ctx context.Context, in *WithdrawCommentCreateRequest, opts ...grpc.CallOption) (*WithdrawCommentCreateResponse, error)
	// (ADMIN) WithdrawCommentList
	WithdrawCommentList(ctx context.Context, in *WithdrawCommentListRequest, opts ...grpc.CallOption) (*WithdrawCommentListResponse, error)
}

type tomanWithdrawClient struct {
	cc grpc.ClientConnInterface
}

func NewTomanWithdrawClient(cc grpc.ClientConnInterface) TomanWithdrawClient {
	return &tomanWithdrawClient{cc}
}

func (c *tomanWithdrawClient) WithdrawTrxInit(ctx context.Context, in *WithdrawTrxInitRequest, opts ...grpc.CallOption) (*WithdrawTrxInitResponse, error) {
	out := new(WithdrawTrxInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawTrxInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawHistory(ctx context.Context, in *WithdrawHistoryRequest, opts ...grpc.CallOption) (*WithdrawHistoryResponse, error) {
	out := new(WithdrawHistoryResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawManualInit(ctx context.Context, in *WithdrawManualInitRequest, opts ...grpc.CallOption) (*WithdrawManualInitResponse, error) {
	out := new(WithdrawManualInitResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawManualInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawProceed(ctx context.Context, in *WithdrawProceedRequest, opts ...grpc.CallOption) (*WithdrawProceedResponse, error) {
	out := new(WithdrawProceedResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawProceed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawFilter(ctx context.Context, in *WithdrawFilterRequest, opts ...grpc.CallOption) (*WithdrawFilterResponse, error) {
	out := new(WithdrawFilterResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawFilter", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawTrxFinalize(ctx context.Context, in *WithdrawTrxFinalizeRequest, opts ...grpc.CallOption) (*WithdrawTrxFinalizeResponse, error) {
	out := new(WithdrawTrxFinalizeResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawTrxFinalize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawNotifySuccess(ctx context.Context, in *WithdrawNotifySuccessRequest, opts ...grpc.CallOption) (*WithdrawNotifySuccessResponse, error) {
	out := new(WithdrawNotifySuccessResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawNotifySuccess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawNotifyFailure(ctx context.Context, in *WithdrawNotifyFailureRequest, opts ...grpc.CallOption) (*WithdrawNotifyFailureResponse, error) {
	out := new(WithdrawNotifyFailureResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawNotifyFailure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawTrxFill(ctx context.Context, in *WithdrawTrxFillRequest, opts ...grpc.CallOption) (*WithdrawTrxFillResponse, error) {
	out := new(WithdrawTrxFillResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawTrxFill", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawSettlementDeclare(ctx context.Context, in *WithdrawSettlementDeclareRequest, opts ...grpc.CallOption) (*WithdrawSettlementDeclareResponse, error) {
	out := new(WithdrawSettlementDeclareResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawSettlementDeclare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawCompletenessDeclare(ctx context.Context, in *WithdrawCompletenessDeclareRequest, opts ...grpc.CallOption) (*WithdrawCompletenessDeclareResponse, error) {
	out := new(WithdrawCompletenessDeclareResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawCompletenessDeclare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawMakeCorrective(ctx context.Context, in *WithdrawMakeCorrectiveRequest, opts ...grpc.CallOption) (*WithdrawMakeCorrectiveResponse, error) {
	out := new(WithdrawMakeCorrectiveResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawMakeCorrective", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawCommentCreate(ctx context.Context, in *WithdrawCommentCreateRequest, opts ...grpc.CallOption) (*WithdrawCommentCreateResponse, error) {
	out := new(WithdrawCommentCreateResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawCommentCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tomanWithdrawClient) WithdrawCommentList(ctx context.Context, in *WithdrawCommentListRequest, opts ...grpc.CallOption) (*WithdrawCommentListResponse, error) {
	out := new(WithdrawCommentListResponse)
	err := c.cc.Invoke(ctx, "/financialCoordinator.toman.TomanWithdraw/WithdrawCommentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TomanWithdrawServer is the server API for TomanWithdraw service.
// All implementations must embed UnimplementedTomanWithdrawServer
// for forward compatibility
type TomanWithdrawServer interface {
	// (USER) WithdrawTrxInit initializes withdraw request
	WithdrawTrxInit(context.Context, *WithdrawTrxInitRequest) (*WithdrawTrxInitResponse, error)
	// (USER) WithdrawHistory
	WithdrawHistory(context.Context, *WithdrawHistoryRequest) (*WithdrawHistoryResponse, error)
	// (ADMIN) WithdrawManualInit initializes withdraw request
	// reuslting status will be 'waiting for admin'
	WithdrawManualInit(context.Context, *WithdrawManualInitRequest) (*WithdrawManualInitResponse, error)
	// (ADMIN) WithdrawProceed takes aciton on Withdraw  transaciton
	// Only works for 'waiting for admin', 'miscarried' or 'frozen' trxs
	WithdrawProceed(context.Context, *WithdrawProceedRequest) (*WithdrawProceedResponse, error)
	// (ADMIN) DepositFilter
	WithdrawFilter(context.Context, *WithdrawFilterRequest) (*WithdrawFilterResponse, error)
	// (FIAT-GW) WithdrawTrxFinalize insert fills related to withdraw trx into db
	// and finalizes with accounting.
	// resulting status would be 'successful'
	WithdrawTrxFinalize(context.Context, *WithdrawTrxFinalizeRequest) (*WithdrawTrxFinalizeResponse, error)
	// (FIAT-GW) WithdrawNotifySuccess insert fills related to withdraw trx into db
	// and finalizes with accounting.
	// resulting status would be 'successful'
	WithdrawNotifySuccess(context.Context, *WithdrawNotifySuccessRequest) (*WithdrawNotifySuccessResponse, error)
	// (FIAT-GW) WithdrawNotifyFailure updates withdraw trx.
	// resulting status would be 'miscarried'
	WithdrawNotifyFailure(context.Context, *WithdrawNotifyFailureRequest) (*WithdrawNotifyFailureResponse, error)
	// (FIAT-GW) WithdrawTrxFill update fills with RRNs
	WithdrawTrxFill(context.Context, *WithdrawTrxFillRequest) (*WithdrawTrxFillResponse, error)
	// (ADMIN) WithdrawSettlementDeclare gets settlement info from admin and finalize to accounting based on it.
	// Only works for 'waiting for admin', 'miscarried', 'acc-finalize-failed' or 'frozen' trxs
	WithdrawSettlementDeclare(context.Context, *WithdrawSettlementDeclareRequest) (*WithdrawSettlementDeclareResponse, error)
	// (ADMIN) WithdrawCompletenessDeclare gets RRNs from admin and updates the trx fills.
	// Only 'successful' trx.
	// resulting status would be 'completed'
	// it can be used for 'completed' trxs to update fills.
	WithdrawCompletenessDeclare(context.Context, *WithdrawCompletenessDeclareRequest) (*WithdrawCompletenessDeclareResponse, error)
	// (ADMIN) WithdrawMakeCorrective reverts a withdraw transaction.
	// Only works for 'successful' or 'completed' trxs
	WithdrawMakeCorrective(context.Context, *WithdrawMakeCorrectiveRequest) (*WithdrawMakeCorrectiveResponse, error)
	// (ADMIN) WithdrawCommentCreate
	WithdrawCommentCreate(context.Context, *WithdrawCommentCreateRequest) (*WithdrawCommentCreateResponse, error)
	// (ADMIN) WithdrawCommentList
	WithdrawCommentList(context.Context, *WithdrawCommentListRequest) (*WithdrawCommentListResponse, error)
	mustEmbedUnimplementedTomanWithdrawServer()
}

// UnimplementedTomanWithdrawServer must be embedded to have forward compatible implementations.
type UnimplementedTomanWithdrawServer struct {
}

func (UnimplementedTomanWithdrawServer) WithdrawTrxInit(context.Context, *WithdrawTrxInitRequest) (*WithdrawTrxInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawTrxInit not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawHistory(context.Context, *WithdrawHistoryRequest) (*WithdrawHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawHistory not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawManualInit(context.Context, *WithdrawManualInitRequest) (*WithdrawManualInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawManualInit not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawProceed(context.Context, *WithdrawProceedRequest) (*WithdrawProceedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawProceed not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawFilter(context.Context, *WithdrawFilterRequest) (*WithdrawFilterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawFilter not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawTrxFinalize(context.Context, *WithdrawTrxFinalizeRequest) (*WithdrawTrxFinalizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawTrxFinalize not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawNotifySuccess(context.Context, *WithdrawNotifySuccessRequest) (*WithdrawNotifySuccessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawNotifySuccess not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawNotifyFailure(context.Context, *WithdrawNotifyFailureRequest) (*WithdrawNotifyFailureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawNotifyFailure not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawTrxFill(context.Context, *WithdrawTrxFillRequest) (*WithdrawTrxFillResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawTrxFill not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawSettlementDeclare(context.Context, *WithdrawSettlementDeclareRequest) (*WithdrawSettlementDeclareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawSettlementDeclare not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawCompletenessDeclare(context.Context, *WithdrawCompletenessDeclareRequest) (*WithdrawCompletenessDeclareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawCompletenessDeclare not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawMakeCorrective(context.Context, *WithdrawMakeCorrectiveRequest) (*WithdrawMakeCorrectiveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawMakeCorrective not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawCommentCreate(context.Context, *WithdrawCommentCreateRequest) (*WithdrawCommentCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawCommentCreate not implemented")
}
func (UnimplementedTomanWithdrawServer) WithdrawCommentList(context.Context, *WithdrawCommentListRequest) (*WithdrawCommentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WithdrawCommentList not implemented")
}
func (UnimplementedTomanWithdrawServer) mustEmbedUnimplementedTomanWithdrawServer() {}

// UnsafeTomanWithdrawServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TomanWithdrawServer will
// result in compilation errors.
type UnsafeTomanWithdrawServer interface {
	mustEmbedUnimplementedTomanWithdrawServer()
}

func RegisterTomanWithdrawServer(s grpc.ServiceRegistrar, srv TomanWithdrawServer) {
	s.RegisterService(&TomanWithdraw_ServiceDesc, srv)
}

func _TomanWithdraw_WithdrawTrxInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawTrxInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawTrxInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawTrxInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawTrxInit(ctx, req.(*WithdrawTrxInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawHistory(ctx, req.(*WithdrawHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawManualInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawManualInitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawManualInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawManualInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawManualInit(ctx, req.(*WithdrawManualInitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawProceed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawProceedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawProceed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawProceed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawProceed(ctx, req.(*WithdrawProceedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawFilter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawFilterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawFilter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawFilter",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawFilter(ctx, req.(*WithdrawFilterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawTrxFinalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawTrxFinalizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawTrxFinalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawTrxFinalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawTrxFinalize(ctx, req.(*WithdrawTrxFinalizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawNotifySuccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawNotifySuccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawNotifySuccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawNotifySuccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawNotifySuccess(ctx, req.(*WithdrawNotifySuccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawNotifyFailure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawNotifyFailureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawNotifyFailure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawNotifyFailure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawNotifyFailure(ctx, req.(*WithdrawNotifyFailureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawTrxFill_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawTrxFillRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawTrxFill(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawTrxFill",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawTrxFill(ctx, req.(*WithdrawTrxFillRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawSettlementDeclare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawSettlementDeclareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawSettlementDeclare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawSettlementDeclare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawSettlementDeclare(ctx, req.(*WithdrawSettlementDeclareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawCompletenessDeclare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawCompletenessDeclareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawCompletenessDeclare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawCompletenessDeclare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawCompletenessDeclare(ctx, req.(*WithdrawCompletenessDeclareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawMakeCorrective_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawMakeCorrectiveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawMakeCorrective(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawMakeCorrective",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawMakeCorrective(ctx, req.(*WithdrawMakeCorrectiveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawCommentCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawCommentCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawCommentCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawCommentCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawCommentCreate(ctx, req.(*WithdrawCommentCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TomanWithdraw_WithdrawCommentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawCommentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TomanWithdrawServer).WithdrawCommentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/financialCoordinator.toman.TomanWithdraw/WithdrawCommentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TomanWithdrawServer).WithdrawCommentList(ctx, req.(*WithdrawCommentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TomanWithdraw_ServiceDesc is the grpc.ServiceDesc for TomanWithdraw service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TomanWithdraw_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "financialCoordinator.toman.TomanWithdraw",
	HandlerType: (*TomanWithdrawServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WithdrawTrxInit",
			Handler:    _TomanWithdraw_WithdrawTrxInit_Handler,
		},
		{
			MethodName: "WithdrawHistory",
			Handler:    _TomanWithdraw_WithdrawHistory_Handler,
		},
		{
			MethodName: "WithdrawManualInit",
			Handler:    _TomanWithdraw_WithdrawManualInit_Handler,
		},
		{
			MethodName: "WithdrawProceed",
			Handler:    _TomanWithdraw_WithdrawProceed_Handler,
		},
		{
			MethodName: "WithdrawFilter",
			Handler:    _TomanWithdraw_WithdrawFilter_Handler,
		},
		{
			MethodName: "WithdrawTrxFinalize",
			Handler:    _TomanWithdraw_WithdrawTrxFinalize_Handler,
		},
		{
			MethodName: "WithdrawNotifySuccess",
			Handler:    _TomanWithdraw_WithdrawNotifySuccess_Handler,
		},
		{
			MethodName: "WithdrawNotifyFailure",
			Handler:    _TomanWithdraw_WithdrawNotifyFailure_Handler,
		},
		{
			MethodName: "WithdrawTrxFill",
			Handler:    _TomanWithdraw_WithdrawTrxFill_Handler,
		},
		{
			MethodName: "WithdrawSettlementDeclare",
			Handler:    _TomanWithdraw_WithdrawSettlementDeclare_Handler,
		},
		{
			MethodName: "WithdrawCompletenessDeclare",
			Handler:    _TomanWithdraw_WithdrawCompletenessDeclare_Handler,
		},
		{
			MethodName: "WithdrawMakeCorrective",
			Handler:    _TomanWithdraw_WithdrawMakeCorrective_Handler,
		},
		{
			MethodName: "WithdrawCommentCreate",
			Handler:    _TomanWithdraw_WithdrawCommentCreate_Handler,
		},
		{
			MethodName: "WithdrawCommentList",
			Handler:    _TomanWithdraw_WithdrawCommentList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "financial-coordinator/toman/services.proto",
}
